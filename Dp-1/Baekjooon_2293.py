#백준 2293번 동전 1

#시간 제한이 0.5초이고, 추가 시간이 아예 없다?
#DP 문제인 것은 알겠으나, 해결 로직이 감이 안잡힌다

import sys

input = sys.stdin.readline

#동전 종류 N, 목표 금액 K 입력
N, K = map(int, input().split())

coins = []
K_list = [0] * (K+1)

for i in range(N):
    coins.append(int(input()))

coins.sort() #동전 종류 가치 오름차순 정렬렬

#우선 고민해보자, 어떻게 해야 K를 만드는 경우의 수를 전부 계산할 수 있지?
#DP 라는 것은, 큰 문제를 작은 문제로 나누어 작은 문제의 값을 활용해 답을 얻어내는 거잖아.
#그럼 이 문제에서는 어떻게 큰 문제를 작은 문제로 나눌 수 있을까?
#1원 ~ K원 을 달성하는 모든 경우의 수를 연산하다 보면은, 결국 K원을 만드는 경우의 수를 구할 수 있지 않을까?

#외부 루프를 K로 생각하였는데, 
#N으로 돌리는 편이 가격이 낮은 동전에 대한 경우의 수를 먼저 구해서 연산에 활용할 수 있다.
for i in range(N) :

    #현재 취급하는 동전에 대해 이 동전을 활용하여 K원까지 만드는 경우의 수를 계산
    for j in range(coins[i], K + 1):

        #동전의 가격 == 목표로 하는 금액(j) 면, 동전 하나만 쓰면 되니 +1 하면 된다
        if j == coins[i] :
            K_list[j] += 1

        #목표로 하는 금액(j)의 경우의 수에는, j - coins[i] 즉
        #현재 목표 금액에서 i번째 동전의 값을 뺀 금액의 경우의 수에, i번째 동전 하나를 추가하면 된다다
        else :
            K_list[j] += K_list[j - coins[i]]


#[0, 1, 2, 2, 3, 4, 5, 6, 7, 8, 10]

print(K_list[K])









